import * as anchor from "@coral-xyz/anchor";
import { PublicKey, Keypair, SystemProgram } from "@solana/web3.js";
import { TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID } from "@solana/spl-token";
import { Ddd } from "../target/types/ddd";

/**
 * Accept offer and lock crypto (creates order + vault + ticket, locks tokens)
 * This is the FIRST blockchain transaction when counterparty accepts a DB offer
 * 
 * @param program - Anchor program instance
 * @param orderId - Blockchain order ID (u64, generated by backend)
 * @param ticketId - Ticket ID (u64, always 1 for first ticket)
 * @param cryptoAmount - Amount of crypto tokens (u64)
 * @param fiatAmount - Amount of fiat currency (u64)
 * @param isSellOrder - true = SELL, false = BUY
 * @param creator - Who created the DB offer
 * @param fiatGuy - Who pays fiat (buyer)
 * @param cryptoGuy - Who locks crypto tokens (seller)
 * @param cryptoGuyAta - CryptoGuy's token account
 * @param mint - Token mint (USDC, etc.)
 * @param adminSigner - Admin keypair (pays rent)
 * @returns Transaction signature
 */
export async function acceptOfferAndLock(
    program: anchor.Program<Ddd>,
    orderId: anchor.BN,
    ticketId: anchor.BN,
    cryptoAmount: anchor.BN,
    fiatAmount: anchor.BN,
    isSellOrder: boolean,
    creator: PublicKey,
    fiatGuy: PublicKey,
    cryptoGuy: Keypair,
    cryptoGuyAta: PublicKey,
    mint: PublicKey,
    adminSigner: Keypair
): Promise<{ signature: string; orderPda: PublicKey; vaultPda: PublicKey; ticketPda: PublicKey }> {
    // Derive PDAs
    const orderIdBuf = orderId.toArrayLike(Buffer, "le", 8);
    const [orderPda] = PublicKey.findProgramAddressSync(
        [Buffer.from("universal_order"), creator.toBuffer(), mint.toBuffer(), orderIdBuf],
        program.programId
    );
    const [vaultPda] = PublicKey.findProgramAddressSync(
        [Buffer.from("vault"), orderPda.toBuffer()],
        program.programId
    );
    const ticketIdBuf = ticketId.toArrayLike(Buffer, "le", 8);
    const [ticketPda] = PublicKey.findProgramAddressSync(
        [Buffer.from("ticket"), orderPda.toBuffer(), ticketIdBuf],
        program.programId
    );

    const signature = await (program.methods as any)
        .acceptOfferAndLock(
            orderId,
            ticketId,
            cryptoAmount,
            fiatAmount,
            isSellOrder,
            creator,
            fiatGuy
        )
        .accounts({
            feePayer: adminSigner.publicKey,
            locker: cryptoGuy.publicKey,
            order: orderPda,
            mint: mint,
            vault: vaultPda,
            ticket: ticketPda,
            lockerTokenAccount: cryptoGuyAta,
            tokenProgram: TOKEN_PROGRAM_ID,
            associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
        })
        .signers([adminSigner, cryptoGuy])
        .rpc();

    return { signature, orderPda, vaultPda, ticketPda };
}

/**
 * Helper to sign a ticket (for both CryptoGuy and FiatGuy)
 * 
 * NOTE: Token accounts must always be provided, even for first signature.
 * Rust code checks them only when both parties have signed (settlement).
 * 
 * @param program - Anchor program instance
 * @param signer - Party signing the ticket
 * @param orderPda - Order PDA
 * @param vaultPda - Vault PDA
 * @param ticketPda - Ticket PDA
 * @param fiatGuyAta - FiatGuy's token account (receives crypto)
 * @param adminTokenAccount - Admin's token account (receives fee)
 * @param adminSigner - Admin keypair (pays transaction fee)
 * @returns Transaction signature
 */
export async function signTicket(
    program: anchor.Program<Ddd>,
    signer: Keypair,
    orderPda: PublicKey,
    vaultPda: PublicKey,
    ticketPda: PublicKey,
    fiatGuyAta: PublicKey,
    adminTokenAccount: PublicKey,
    adminSigner: Keypair
): Promise<string> {
    return await (program.methods as any)
        .signUniversalTicket()
        .accounts({
            feePayer: adminSigner.publicKey,
            signer: signer.publicKey,
            adminRentReceiver: adminSigner.publicKey,
            order: orderPda,
            vault: vaultPda,
            ticket: ticketPda,
            fiatGuyTokenAccount: fiatGuyAta,
            adminFeeAccount: adminTokenAccount,
            tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([adminSigner, signer])
        .rpc();
}

/**
 * Cancel a ticket (FiatGuy only, before signing)
 * Refunds tokens to CryptoGuy and auto-closes order + vault
 * 
 * @param program - Anchor program instance
 * @param canceller - FiatGuy (only they can cancel)
 * @param orderPda - Order PDA
 * @param vaultPda - Vault PDA
 * @param ticketPda - Ticket PDA
 * @param cryptoGuyAta - CryptoGuy's token account (receives refund)
 * @param adminSigner - Admin keypair (pays transaction fee)
 * @returns Transaction signature
 */
export async function cancelTicket(
    program: anchor.Program<Ddd>,
    canceller: Keypair,
    orderPda: PublicKey,
    vaultPda: PublicKey,
    ticketPda: PublicKey,
    cryptoGuyAta: PublicKey,
    adminSigner: Keypair
): Promise<string> {
    return await (program.methods as any)
        .cancelUniversalTicket()
        .accounts({
            feePayer: adminSigner.publicKey,
            canceller: canceller.publicKey,
            adminRentReceiver: adminSigner.publicKey,
            order: orderPda,
            vault: vaultPda,
            ticket: ticketPda,
            cryptoGuyTokenAccount: cryptoGuyAta,
            tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([adminSigner, canceller])
        .rpc();
}

/**
 * Derive Order and Vault PDAs
 */
export function deriveOrderPdas(
    programId: PublicKey,
    creator: PublicKey,
    mint: PublicKey,
    orderId: anchor.BN
): { orderPda: PublicKey; vaultPda: PublicKey } {
    const orderSeed = Buffer.from("universal_order");
    const vaultSeed = Buffer.from("vault");
    const orderIdBuf = orderId.toArrayLike(Buffer, "le", 8);

    const [orderPda] = PublicKey.findProgramAddressSync(
        [orderSeed, creator.toBuffer(), mint.toBuffer(), orderIdBuf],
        programId
    );

    const [vaultPda] = PublicKey.findProgramAddressSync(
        [vaultSeed, orderPda.toBuffer()],
        programId
    );

    return { orderPda, vaultPda };
}

/**
 * Derive Ticket PDA
 */
export function deriveTicketPda(
    programId: PublicKey,
    orderPda: PublicKey,
    ticketId: anchor.BN
): PublicKey {
    const [ticketPda] = PublicKey.findProgramAddressSync(
        [Buffer.from("ticket"), orderPda.toBuffer(), ticketId.toArrayLike(Buffer, "le", 8)],
        programId
    );
    return ticketPda;
}
